#pragma config(Sensor, in1,    lineFollower,  sensorLineFollower)
#pragma config(Sensor, dgtl1,  bumpSensor,    sensorTouch)
#pragma config(Motor,  port2,  leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,  rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Servo,  port6,  armServo,      tServoStandard)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const float Kp = 0.5;
const float Ki = 0.01;
const float Kd = 0;

int error = 0;
int integral = 0;
int lastError = 0;
int derivative = 0;
bool lineFollowerMode = false;
bool buttonPressedLastCycle = false;
int servoPosition = 127 / 2; // Start at the midpoint, assuming a range of 0 to 127
const int servoChangeRate = 1; // Adjust the servo movement speed as needed
bool btn5UPressedLastCycle = false;
bool btn5DPressedLastCycle = false;

int leftMotorPower = 0;
int rightMotorPower = 0;
const int accelerationStep = 10; // The amount of power to increase per cycle
const int controlLoopDelay = 25; // Control loop delay in milliseconds

// Function to ramp motor power smoothly
int rampMotorPower(int currentPower, int targetPower) {
  if (abs(currentPower - targetPower) < accelerationStep) {
    return targetPower; // Close enough to target to apply power directly
  } else if (currentPower < targetPower) {
    return currentPower + accelerationStep; // Ramp up
  } else {
    return currentPower - accelerationStep; // Ramp down
  }
}

task main() {
  while(true) {
    // Emergency stop
    if (vexRT[Btn8U]) { // Assuming button 8 up is your emergency stop
      motor[leftMotor] = 0;
      motor[rightMotor] = 0;
      setServo(armServo, 127/2); // Optionally center the servo
      while(vexRT[Btn8U]) { // Wait in this state until the button is released
        wait1Msec(100);
      }
      continue; // Skip the rest of the loop and start over
    }

    // Toggle line follower mode with a button press
    if (vexRT[Btn6U] && !buttonPressedLastCycle) {
      lineFollowerMode = !lineFollowerMode;
      integral = 0;
      buttonPressedLastCycle = true;
    } else if (!vexRT[Btn6U]) {
      buttonPressedLastCycle = false;
    }

    // Tank control with smooth acceleration
    if (!lineFollowerMode) {
      int targetLeftPower = vexRT[Ch3];
      int targetRightPower = vexRT[Ch2];

      leftMotorPower = rampMotorPower(leftMotorPower, targetLeftPower);
      rightMotorPower = rampMotorPower(rightMotorPower, targetRightPower);

      motor[leftMotor] = leftMotorPower;
      motor[rightMotor] = rightMotorPower;
    }

    // Line follower mode
    if (lineFollowerMode) {
      // Bump sensor check
      if (SensorValue[bumpSensor] == 1) {
        motor[leftMotor] = 0;
        motor[rightMotor] = 0;
        continue; // Skip the rest of the loop if bump sensor is triggered
      }

      // PID control for line following
      error = SensorValue[lineFollower] - 2000;
      integral = integral + error;
      derivative = error - lastError;
      lastError = error;
      motor[leftMotor] = Kp * error + Ki * integral + Kd * derivative;
      motor[rightMotor] = Kp * error - Ki * integral - Kd * derivative;
    }

    // Servo control with debounce logic
    if (vexRT[Btn5U] && !btn5UPressedLastCycle) {
      servoPosition += servoChangeRate;
      btn5UPressedLastCycle = true;
    } else if (!vexRT[Btn5U]) {
      btn5UPressedLastCycle = false;
    }

    if (vexRT[Btn5D] && !btn5DPressedLastCycle) {
      servoPosition -= servoChangeRate;
      btn5DPressedLastCycle = true;
    } else if (!vexRT[Btn5D]) {
      btn5DPressedLastCycle = false;
    }

    // Keep the servo position within valid range
    servoPosition = max(0, min(127, servoPosition));
    setServo(armServo, servoPosition);

    wait1Msec(controlLoopDelay); // Control loop delay
  }
}
