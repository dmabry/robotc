#pragma config(Sensor, in1,    lineFollower,  sensorLineFollower)
#pragma config(Sensor, dgtl1,  bumpSensor,    sensorTouch)
#pragma config(Motor,  port2,   leftMotor,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,   rightMotor,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,   armMotor,      tmotorServoStandard, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

const int servoChangeRate = 1; // Adjust this to set the increment step for the servo
const int controlLoopDelay = 25; // Milliseconds for the control loop delay
const float accelerationStep = 0.1; // Adjust this for smoother acceleration

// Variables for tank control smoothing
float leftMotorSpeed = 0;
float rightMotorSpeed = 0;

// Variables for debouncing button presses
bool btn5UPressedLastCycle = false;
bool btn5DPressedLastCycle = false;
bool btn6UPressedLastCycle = false;

int armMotorPosition = 0; // Variable to store the arm motor position

// Line follower PID constants
float Kp = 0.5; // Proportional constant
float Ki = 0.01; // Integral constant
float Kd = 0; // Derivative constant

// Line follower variables
int error = 0;
int integral = 0;
int derivative = 0;
int lastError = 0;
bool lineFollowerActive = false; // Tracks whether line follower mode is active

task main() {
	while(true) {
		if (vexRT[Btn6U] && !btn6UPressedLastCycle) {
			lineFollowerActive = !lineFollowerActive; // Toggle line follower mode
			btn6UPressedLastCycle = true;
			} else if (!vexRT[Btn6U]) {
			btn6UPressedLastCycle = false;
		}

		if (lineFollowerActive) {
			// Read the line follower sensor
			error = SensorValue[lineFollower] - 2000;
			integral += error;
			derivative = error - lastError;
			lastError = error;

			// Compute the PID output for motor speed
			leftMotorSpeed = Kp*error + Ki*integral + Kd*derivative;
			rightMotorSpeed = leftMotorSpeed;

			// Check for the bump sensor being pressed
			if (SensorValue[bumpSensor] == 1) {
				leftMotorSpeed = 0;
				rightMotorSpeed = 0;
			}
			} else {
			// Tank control
			// Acceleration for left motor
			if (abs(vexRT[Ch3] - leftMotorSpeed) > accelerationStep) {
				leftMotorSpeed += vexRT[Ch3] > leftMotorSpeed ? accelerationStep : -accelerationStep;
				} else {
				leftMotorSpeed = vexRT[Ch3];
			}

			// Acceleration for right motor
			if (abs(vexRT[Ch2] - rightMotorSpeed) > accelerationStep) {
				rightMotorSpeed += vexRT[Ch2] > rightMotorSpeed ? accelerationStep : -accelerationStep;
				} else {
				rightMotorSpeed = vexRT[Ch2];
			}
		}

		// Write the computed speeds to the motors
		motor[leftMotor] = (int)leftMotorSpeed;
		motor[rightMotor] = (int)rightMotorSpeed;

		// Servo control with debounce logic for arm
		if (vexRT[Btn5U] && !btn5UPressedLastCycle) {
			armMotorPosition += servoChangeRate;
			btn5UPressedLastCycle = true;
			} else if (!vexRT[Btn5U]) {
			btn5UPressedLastCycle = false;
		}

		if (vexRT[Btn5D] && !btn5DPressedLastCycle) {
			armMotorPosition -= servoChangeRate;
			btn5DPressedLastCycle = true;
			} else if (!vexRT[Btn5D]) {
			btn5DPressedLastCycle = false;
		}

		// Keep the arm motor position within the valid range
		armMotorPosition = (armMotorPosition < -127) ? -127 : (armMotorPosition > 127 ? 127 : armMotorPosition);

		// Write the position to the arm motor
		motor[armMotor] = armMotorPosition;

		wait1Msec(controlLoopDelay); // Wait for the control loop delay
	}
}
