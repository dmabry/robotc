#pragma config(Sensor, in2,    lineTracker,         sensorLineFollower)
#pragma config(Motor,  port1,           leftMotor,    tmotorNormal, openLoop, reversed)
#pragma config(Motor,  port10,           rightMotor,     tmotorNormal, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

/*----------------------------------------------------------------------------------------------------*\
|*    NOTES:                                                                                          *|
|*    Lighting conditions, line darkness, and surface lightness change from place to place,           *|
|*    so the value of 'threshold' may need to be changed to better suit your environment.             *|
|*                                                                                                    *|
|*    MOTORS & SENSORS:                                                                               *|
|*    [I/O Port]          [Name]              [Type]                [Description]                     *|
|*    Motor  - Port 2     rightMotor          VEX 3-wire module     Right side motor                  *|
|*    Motor  - Port 3     leftMotor           VEX 3-wire module     Left side motor                   *|
|*    Analog - Port 2     lineTracker         VEX Light Sensor      Front-center, facing down         *|
\*-----------------------------------------------------------------------------------------------4246-*/


//+++++++++++++++++++++++++++++++++++++++++++++| MAIN |+++++++++++++++++++++++++++++++++++++++++++++++
task main()
{
	wait1Msec(1000);// wait 1 seconds before starting.
	int threshold = 2000;// found by taking a reading on both DARK and LIGHT surfaces, adding them together, then dividing by 2.
	int sweepStep = 110;
	int sweepCount = 0;
	int sweepLimit = 10;
	int reverseFactor = 5;
	// start line following
	while(true)
	{
		// sensor sees line:
		if(SensorValue(lineTracker) >= threshold){
			// proceed forward:
			motor[leftMotor]  = 63;
			motor[rightMotor] = 63;
			} else {
			sweepCount = 0;
			int lastDiff = threshold - SensorValue(lineTracker);
			motor[leftMotor]  = 0;
			motor[rightMotor] = 63;
			wait1Msec(sweepStep);
			int currentDiff = threshold - SensorValue(lineTracker);
			bool leftTurnLast = true;
			sweepCount = 0;
			while (sweepCount <= sweepLimit){
				if (currentDiff > lastDiff){
					// Further away turn back
					if (leftTurnLast) {
						lastDiff = currentDiff;
						motor[leftMotor]  = 63;
						motor[rightMotor] = 0;
						wait1Msec(sweepStep*2);
						leftTurnLast = false;
						currentDiff = threshold - SensorValue(lineTracker);
						} else {
						lastDiff = currentDiff;
						motor[leftMotor] = 0;
						motor[rightMotor] = 63;
						wait1Msec(sweepStep*2);
						leftTurnLast = true;
						currentDiff = threshold - SensorValue(lineTracker);
					}
				}
				if (currentDiff <= lastDiff){
					// Closer keep going
					if (leftTurnLast) {
						lastDiff = currentDiff;
						motor[leftMotor]  = 0;
						motor[rightMotor] = 63;
						wait1Msec(sweepStep);
						leftTurnLast = true;
						currentDiff = threshold - SensorValue(lineTracker);
						} else {
						lastDiff = currentDiff;
						motor[leftMotor] = 63;
						motor[rightMotor] = 0;
						wait1Msec(sweepStep);
						leftTurnLast = false;
						currentDiff = threshold - SensorValue(lineTracker);
					}
				}
				if (SensorValue[lineTracker] >= threshold){
					break;
					} else {
					sweepCount += 1;
				}
				//Missed completely, backup
				motor[leftMotor] = -30;
				motor[rightMotor] = -30;
				wait1Msec(sweepStep*reverseFactor);
			}
		}
		//wait1Msec(25);
	}
}
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
